Енумерациите държат сет/множество от константи - стойностите вътре НЕ МОГАТ да се повтарят.
Default toString на енумерациите връща самото име - вика .name();
Хубаво е в края на енумерациите да има ; , защото ако след това напишем логика отдолу няма
да се компилира без ;
Константите си имат и индекси - zero based.
season.ordinal() - дава индекса на конкретната константа в енумерацията

Enum.valueOf(Season.class, "SUMMER"); - лекичко рефлекшън :) - трябва да подадем инфо за
това какъв клас искаме да създадем. Не се добавя, взима съществуваща. Така просто взимаме
енумерация по подаден стринг

    public static final Comparator<WeeklyEntry> BY_WEEKDAY = getComparatorByWeekday(); !!!

По конвенция всяка анотация е на собствен ред.
Ако анотацията има само 1 параметър и той е value можем да изпуснем value =

В анотацията имаме ЕЛЕМЕНТИ, не полета. String myValue() default "def";
Може и без default стойност
Елементите могат да бъдат примитивни, String, Enum, Annotation, Class (от рефлекшън) и масив
от горните неща

Метаанотация - информация за анотацията. По какъв начин нашата анотация ще бъде достъпна и 
по какъв начин ще може да се ползва.

@Target - къде ще прилагаме анотацията ни - методи, полета, класове.....
@Target(ElementType.FIELD) - вградена енумерация. TYPE са класове, енумерации и т.н.
м
@Retention - по какъв начин ще можем да извлечем инфо от анотацията
@Retention(RetentionPolicy.RUNTIME) - SOURCE, CLASS, RUNTIME
SOURCE - достъпна е само за четене на source файловете
CLASS - след компилиране на java файла в сорс файла, вече ще я има анотацията и в компилирания
клас файл
RUNTIME - първите 2 + самата програма ще знае за тях runtime

Имат си default стойност и в този смисъл за задължителни. НО е по-добре да ги има за четимост.
