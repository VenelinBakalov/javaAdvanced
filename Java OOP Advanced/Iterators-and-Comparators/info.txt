spliterator - разделя колекцията, така че да може да се обработва на различни нишки.
НИКОГА не имплементираме в един клас ЕДНОВРЕМЕННО iterable<T> и iterator
Iterator pattern - nested class private final class LibIterator implements Iterator<T>. Има логика, никой
не го вижда и ТОЗИ КЛАС Е FINAL!!!
Има клас, който имплементира Iterable, вътре имаме Nested Iterator, който държи логиката за итериране.

while (hasNext) -> next
!!!!!!!!!!!!!!!!! LibIterator-а не трябва да има тип, защото скрива типа на Library-то

ЛОША практика е return new Iterator<T>() { .....} - АНОНИМЕН КЛАС НЕ Е ОК

Fail fast и fail safe.

При fail safe iterator се прави копие и се итерира по него. КОПИЕ, нова инстанция, не референция. Това обаче дава проблеми с паметта.
ConcurrentHashMap....

Компаратора сравнява 2 независими обекта, може да не знаят как се сравняват, може да не са Comparable. 
Comparable сравнява ТЕКУЩАТА инстанция/референция на обект и тя знае как се сравнява.

Custom Comparator - не искам да ползвам compareTo на обекта, не искам да завися от него
Когато нямаме достъп до някакъв обект, ние с компаратор си пишем логиката, по която да го сравняваме.

Примерно фактори за компаратор, интерфейс и ....

КОНСТРУКТУРА НА ИТЕРАТОРА ТРЯБВА ЛИ ДА Е ПУБЛИК
Анонимни класове...? override-ваш само за конкретната инстанция