Модули от високо ниво - тези, които викат други модули, за да им изпълнят нещо.

Модули от високо ниво и модули от ниско ниво трябва да зависят от абстракции.

Пример - бутона държи референция към лампата и при натискане я изключва.
Бутона е High-level/Client. Лампата предоставя turn On/off методите на бутона

Лампата е Low-level/Server

Абстракцията между двете е, че нещо може да бъде включено, изключено.
Switchable Device turnOn() turnOff()
Button uses SwitchableDevice, Lamp implements SwitchableDevice.
Бутона може да е сензор, дистанционно....
Устройството може да е тв, аларма....

Обикновено клиента дефинира интерфейса.

Имаме ли new някъде в класа си директно зависим от него.

Dependency injection - constructors, methods, setters.

Strategy pattern с първа задача - примерно пускаме PrintStream вместо writer и той вече може
да приема различни потоци, на които да изпълнява .println();

Composite Design Pattern - примерно един CompositeNotificationService, който съдържа масив от
NotificationService обекти и се подават през конструктора например като varargs, за да може
клиента да работи директно с него, а не с отделните service. Например ако ползваме клас, 
който е написан да приема само 1 service

UI Layer -> Business Layer -> Data Access Layer. Така обаче всеки слой зависи от следващия,
което НЕ Е DIP. Освен това така могат да работят само като 1 цяло.
Затова вкарваме BL Interface и DAL Interface. Интерфейса на клиента седи на 1 ниво с него.
Клиента определя какъв ще бъде интерфейса.

По package интерфейсите могат да се пакетират с клиента, на нивото на клиента. 

1 модул, който прави нещо определено, изчистваме излишните детайли, оставяме само това, 
което ни интересува отвън

Clients require cohesive interfaces
Всеки който имплементира интерфейс да имплементира точно това което му трябва

Divide FAT interfaces into ROLE interfaces. Когато тръгваме от класа, той има много
методи, защото има много различни роли. Примера с Robot, Employee -> interface Worker ->
методи work, sleep. Robot не му трябва sleep
Fat interface -> increased coupling

Множествено наследяване чрез интерфейси

Adapter Design Patter - if you don't own the library. Нямаме достъп до библиотеката (A) Worker,
Robot, Employee, искаме да добавим Recharge Station -> Rechargable. 
Правим си RobotAdapter - адаптер за класа, в който искаме да вкараме нова функционалност.
Този адаптер държи в себе си инстанция от класа, който не притежаваме. И вече през него викаме
Recharge и действаме върху робота.

Let the client define the interfaces.